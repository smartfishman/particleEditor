export let data={
    "base_frag": "//基础着色器，顶点和片元都直接通过属性注入。\nprecision mediump float;\nuniform sampler2D u_image;\n\nuniform vec4 color;\nuniform float USE_TEXTURE;\n\nvarying vec2 v_texcoord;\n\nfloat near = 1.0;\nfloat far = 1000.0;\nfloat LinearizeDepth(float depth) {\n    float z = depth * 2.0 - 1.0; // back to NDC \n    return (2.0 * near * far) / (far + near - z * (far - near));\n}\n\nvoid main() {\n    if(USE_TEXTURE == 1.0) {\n        // float depth = texture2D(u_image, v_texcoord).r;\n        // depth = LinearizeDepth(depth) / far;\n        // gl_FragColor = vec4(depth, depth, depth, 1.0);\n        gl_FragColor = vec4(texture2D(u_image, v_texcoord).rgb, 1.0);\n    } else {\n        gl_FragColor = color;\n    }\n}",
    "base_vert": "//基础着色器，顶点和片元都直接通过属性注入。\nattribute vec3 position;\nattribute vec2 a_texcoord;\n\nuniform mat4 matViewProj;\nuniform mat4 matWorld;\nuniform mat4 matWorld2;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n    v_texcoord = a_texcoord;\n    vec4 pos = vec4(position, 1);\n    pos = matViewProj * matWorld * pos;\n    gl_Position = pos;\n}\n",
    "coordinateSystem/coordinateSystem_frag": "//空文件",
    "coordinateSystem/coordinateSystem_vert": "//空文件",
    "heatDiffusion/heat_diffusion_frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_image2;\n\nlayout(std140) uniform AAACamera {\n    mat4 matViewProj;\n    vec3 lightColor;\n    vec3 lightPos;\n    vec3 viewPos;\n};\n\nlayout(std140) uniform AAALocal {\n    mat4 matWorld;\n};\n\nin vec3 v_fragWorldPos;\nin vec3 v_normalVector;\nin vec3 v_specialColor;\n\nout vec4 fragColor;\n\nfloat near = 1.0;\nfloat far = 1000.0;\nfloat LinearizeDepth(float depth) {\n    float z = depth * 2.0 - 1.0; // back to NDC \n    return (2.0 * near * far) / (far + near - z * (far - near));\n}\n\nvoid main() {\n    //环境光\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n\n    //漫反射光\n    vec3 norm = normalize(v_normalVector);\n    vec3 lightDir = normalize(lightPos - v_fragWorldPos);\n    float diff = max(dot(norm, lightDir), 0.0);         // 点乘\n    vec3 diffuse = diff * lightColor;\n\n    //镜面反射光\n    float specularStrength = 0.5;\n    vec3 viewDir = normalize(viewPos - v_fragWorldPos);    // 视线方向坐标\n    vec3 reflectDir = reflect(-lightDir, norm);         // 使用reflect函数计算反射光坐标\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = specularStrength * spec * lightColor;\n\n    //vec3 objectColor = texture(u_image2, v_texcoord).rgb;\n    vec3 result = (ambient + diffuse + specular) * v_specialColor.rgb;\n    vec4 color = vec4(result, 1.0);\n\n    fragColor = color;\n}",
    "heatDiffusion/heat_diffusion_vert": "#version 300 es\n\n//每个顶点里传入颜色信息\n\n\nprecision highp float;\n\nin vec3 a_position;\n//法向量\nin vec3 a_normalVector;\nlayout(location = 3) in mat4 a_matWorld;\nlayout(location = 7) in vec3 a_color;\n\nlayout(std140) uniform AAACamera {\n    mat4 matViewProj;\n    vec3 lightColor;\n    vec3 lightPos;\n    vec3 viewPos;\n};\n\nlayout(std140) uniform AAALocal {\n    mat4 matWorld;\n};\n\nout vec3 v_fragWorldPos;\nout vec3 v_normalVector;\nout vec3 v_specialColor;\n\nvoid main() {\n    vec4 localPos = vec4(a_position, 1.0);\n    vec4 pos = matViewProj * a_matWorld * localPos;\n    gl_Position = pos;\n\n    v_specialColor = a_color;\n    v_fragWorldPos = (a_matWorld * localPos).xyz;\n    v_normalVector = a_normalVector;\n}",
    "particle/particle_frag": "precision mediump float;\nuniform sampler2D u_image;\nuniform sampler2D u_font;\nuniform vec3 lightColor;\n\nvarying vec2 v_texcoord;\nvarying float fontEnable;\n\nvoid main(){\n    gl_FragColor = texture2D(u_image,v_texcoord).rgba;\n    if(fontEnable == 1.0){\n        gl_FragColor = texture2D(u_font,v_texcoord).rgba;\n    }\n}",
    "particle/particle_vert": "\n\nattribute vec3 a_position;\nattribute vec2 a_texcoord;\nattribute vec3 a_initialVelocity;\nattribute vec3 a_acceleratedVelocity;\nattribute float a_lifeTime;\nattribute float a_createTime;\n//初始每毫秒逆时针旋转弧度\nattribute float a_initialRotationRate;\n//逆时针旋转弧度的随机波动范围\nattribute float a_rotationRateRange;\nattribute float randSeed;\nattribute vec3 a_worldPos;\n\nuniform mat4 matViewProj;\nuniform mat4 matWorld;\nuniform float u_curTime;\n\nvarying vec2 v_texcoord;\nvarying float fontEnable;\n\n//绕Z轴旋转矩阵\nvoid makeRotationZMat4(inout mat4 outMat,in float rotationRad){\n    vec4 xVec = vec4(cos(rotationRad),sin(rotationRad),0.0,0.0);\n    vec4 yVec = vec4(-sin(rotationRad),cos(rotationRad),0.0,0.0);\n    vec4 zVec = vec4(0.0,0.0,1.0,0.0);\n    vec4 wVec = vec4(0.0,0.0,0.0,1.0);\n    outMat[0] = xVec;\n    outMat[1] = yVec;\n    outMat[2] = zVec;\n    outMat[3] = wVec;\n}\n\n/**平移一个矩阵*/\nvoid translationMat(inout mat4 outMat,in float x,in float y,in float z){\n    outMat[3][0] = x;\n    outMat[3][1] = y;\n    outMat[3][2] = z;\n}\n\n//根据速度和随机种子产生的随机速度计算当前走过的总路程\nfloat getTotalSByRandomV(inout float resultS,in float initV,in float rangeV,in float t,in float lifeTime,in float randSeed){\n    if(rangeV <=0.0){\n        return initV*t;\n    }\n    float random1 = randSeed;\n    float random2 = randSeed;\n    if(random2 > 0.5){\n        random2 -=0.5;\n    }\n    random2 *=  2.0;\n    float range = rangeV / 2.0;\n    float a1 = random1 * lifeTime + 1.0;\n    float a2 = random2 * lifeTime + 1.0;\n    a1 = random2 > 0.5 ? a1 : 1.0 / a1;\n    a2 = random1 > 0.5 ? a2 : 1.0 / a2;\n    // f1 = 25sin(t*a1) f2=25sin(t*a2)\n    //原函数 F1 = -(range/a1)cos(t*a1) F2 = -(range/a2)cos(t*a2)\n    //当前总路程 s1=F1(t)-F1(0) s2=F2(t)-F2(0)\n    float initS = initV * t;\n    float s1 = -(range / a1) * cos(t * a1) - (-(range / a1) * cos(0.0));\n    float s2 = -(range / a2) * cos(t * a2) - (-(range / a2) * cos(0.0));\n    float s = initS + s1 + s2;\n    return s;\n}\n\nvoid main(){\n    fontEnable = 0.0;\n    v_texcoord = a_texcoord;\n\n    float dt = (u_curTime - a_createTime)/1000.0;\n    vec3 offsetPos = (a_initialVelocity+a_initialVelocity+(a_acceleratedVelocity*dt))*0.5*dt;\n    vec3 finalPosition = a_worldPos + offsetPos;\n    vec4 localPos = vec4(a_position,1.0);\n    vec4 worldPos = vec4(finalPosition,1.0);\n    mat4 worldMat = mat4(1.0);\n    translationMat(worldMat,worldPos.x,worldPos.y,worldPos.z);\n    // translationMat(worldMat,50.0,50.0,50.0);\n    mat4 rotationMat = mat4(1.0);\n    if(a_initialRotationRate !=0.0 || a_rotationRateRange>0.0){\n        float rad = 4.0;\n        rad = getTotalSByRandomV(rad,a_initialRotationRate,a_rotationRateRange,dt,a_lifeTime/1000.0,randSeed);\n        makeRotationZMat4(rotationMat,rad);\n    }\n    vec4 pos =  matViewProj * matWorld * worldMat * rotationMat * localPos;\n    gl_Position = pos;\n\n    //调试输出\n    if(a_lifeTime == 9999999.0){\n        pos = vec4(0.5,0.5,0.5,1.0);\n        if(a_texcoord.x ==0.0){\n            pos.x = 0.5;\n        }else{\n            pos.x = 1.0;\n        }\n        if(a_texcoord.y==0.0){\n            pos.y = 1.0;\n        }else{\n            pos.y = 0.5;\n        }\n        fontEnable = 1.0;\n        gl_Position = pos;\n    }\n}\n\n",
    "standard/standard_frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_image2;\n\nlayout(std140) uniform AAACamera {\n    mat4 matViewProj;\n    vec3 lightColor;\n    vec3 lightPos;\n    vec3 viewPos;\n};\n\nlayout(std140) uniform AAALocal {\n    mat4 matWorld;\n};\n\nin vec2 v_texcoord;\nin vec3 v_fragWorldPos;\nin vec3 v_normalVector;\n\nout vec4 fragColor;\n\nfloat near = 1.0;\nfloat far = 1000.0;\nfloat LinearizeDepth(float depth) {\n    float z = depth * 2.0 - 1.0; // back to NDC \n    return (2.0 * near * far) / (far + near - z * (far - near));\n}\n\nvoid main() {\n    //环境光\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n\n    //漫反射光\n    vec3 norm = normalize(v_normalVector);\n    vec3 lightDir = normalize(lightPos - v_fragWorldPos);\n    float diff = max(dot(norm, lightDir), 0.0);         // 点乘\n    vec3 diffuse = diff * lightColor;\n\n    //镜面反射光\n    float specularStrength = 0.5;\n    vec3 viewDir = normalize(viewPos - v_fragWorldPos);    // 视线方向坐标\n    vec3 reflectDir = reflect(-lightDir, norm);         // 使用reflect函数计算反射光坐标\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = specularStrength * spec * lightColor;\n\n    vec3 objectColor = texture(u_image2, v_texcoord).rgb;\n    vec3 result = (ambient + diffuse + specular) * objectColor;\n    vec4 color = vec4(result, 1.0);\n\n    fragColor = color;\n}",
    "standard/standard_vert": "#version 300 es\n\nprecision highp float;\n\nin vec3 a_position;\nin vec2 a_texcoord;\n//法向量\nin vec3 a_normalVector;\nlayout(location = 3) in mat4 a_matWorld;\n\nlayout(std140) uniform AAACamera {\n    mat4 matViewProj;\n    vec3 lightColor;\n    vec3 lightPos;\n    vec3 viewPos;\n};\n\nlayout(std140) uniform AAALocal {\n    mat4 matWorld;\n};\n\nout vec2 v_texcoord;\nout vec3 v_fragWorldPos;\nout vec3 v_normalVector;\n\nvoid main() {\n    vec4 localPos = vec4(a_position, 1.0);\n    vec4 pos = matViewProj * a_matWorld * localPos;\n    gl_Position = pos;\n\n    v_texcoord = a_texcoord;\n    v_fragWorldPos = (a_matWorld * localPos).xyz;\n    v_normalVector = a_normalVector;\n}"
}